# 仓鼠摆一摆 游戏说明文档

汪元标

- 2016010327
- [wang-yb16@mails.tsinghua.edu.cn](wang-yb16@mails.tsinghua.edu.cn)
- [https://github.com/agil27](https://github.com/agil27)

张欣炜

- 2016010151
- [xw-zhang16@mails.tsinghua.edu.cn](xw-zhang16@mails.tsinghua.edu.cn)
- [https://github.com/zhangxwww](https://github.com/zhangxwww)

github repo：

- [https://github.com/zhangxwww/hamswing](https://github.com/zhangxwww/hamswing) (游戏主体代码)
- [https://github.com/agil27/hamswing-sub](https://github.com/agil27/hamswing-sub) (排行榜相关)

小程序码

![小程序码](ext\0.jpg)

---

## 游戏策划与玩法

在游戏中，玩家将会扮演一只森林中仓鼠，利用一根可伸缩钩爪抓住云朵，借助抓钩的力量前进。在路途中，玩家会遇到各种各样的道具，提供各种 buff，也会遇到各种怪物，阻挡仓鼠的前进。玩家需要合理利用抓钩，躲过怪物的攻击，或是借助 buff 的力量，击败面前的怪物。

游戏设计最初的灵感来自于蜘蛛侠，利用蜘蛛丝在城市中来回穿梭。随后演变成一只青蛙，通过吐舌头的方式在森林中前行。最后在游戏开发的过程中逐渐主角演变成了最终版的仓鼠。由于在青蛙阶段，我们就已经完成了代码的主体框架，所以很多代码的命名与实际所代表的物品存在一些差异。例如抓钩，在代码中是用 tongue 表示的，即青蛙的舌头。

游戏中，玩家通过手指按压屏幕来操控仓鼠。按下时，仓鼠会向前方 45 度方向发射一根钩索。这根钩索会抓住屏幕顶部的云层。松开手指，仓鼠会收起钩索，并依靠惯性继续向前飞行。

![长按屏幕，伸出抓钩](ext\tutorial_0.png)

游戏中玩家会遇到两种道具，星星与蘑菇。吃掉星星后，玩家可以在 3 秒内得分翻倍。而吃掉蘑菇后，玩家获得 5 秒的无敌时间。

![收集道具](ext\tutorial_1.png)

同样，玩家会遇到两种怪物，被怪物碰到就会 gg。当然，如果在无敌状态下碰到怪物，可以击败对方。此外，如果玩家操控仓鼠踩到怪物的头，也可以打败怪物。打败怪物后，可以获得额外的加分。

![遇到怪兽](ext\tutorial_2.png)

## 界面布局与设计

进入游戏时，页面如下所示

![开始游戏](ext\layout_start.png)

页面中央为游戏 logo，玩家可以选择进入教学模式，直接开始游戏，或查看好友排行。

游戏中，仓鼠位于屏幕左侧，得分位于屏幕中央。在分数旁边会显示当前拥有的 buff(双倍得分/无敌状态)。

![游戏中](ext\layout_buff.png)

Gameover 时界面如下所示。这里展示了玩家的最终得分，玩家可以选择再来一次，或是返回主菜单。

![Gameover](ext\layout_gameover.png)

## 技术实现方案

本游戏采用 cocos 引擎。场景之间的切换使用 loadScene 函数。游戏的逻辑控制通过组件的生命周期回调实现。

游戏的主体逻辑主要由 canvas 控制，包括按照一定时间与距离间隔生成道具、怪物、云，接收点击事件并分派给其他组件，更新背景及各种物品的位置，记录得分并将分数发送给负责显示分数的组件，清理视野范围外的物品，以及处理 gameover 的情况。

仓鼠相关的逻辑由 ym.js 控制。之所以叫 ym.js，这是上文谈到过的命名的历史遗留问题。在完成这部份代码的时候，游戏的主角还不是仓鼠...... 这部分代码主要处理与仓鼠相关的事件，例如点击屏幕后应该发射钩索，松开手指后应该收回钩索，吃了星星以后会加速，吃了蘑菇以后无敌，等等。

钩索相关的逻辑位于 tongue.js 中，负责钩索的伸长，缩短，钩住(attach)等行为。

怪物相关的逻辑位于 monster.js 与 ghost.js 中。在这两段代码中，我们为怪物增加了更多的动作，包括上下移动，变大变小，以及被玩家踩死以后的下落。

游戏的音效由 audioController.js 控制。这部份代码会监听各种事件，包括吃星星，吃蘑菇，等等，并播放相应的音效。

## 重点与难点

这款游戏的重点在于物理引擎的使用，包括刚体组件，关节组件，以及刚体之间的碰撞处理。

仓鼠需要在森林之中来回飞跃，这需要使用刚体组件来实现其受到重力的效果。将该刚体组件的类型设置为 dynamic，并设置 gravity scale 为 1。

为了能够让仓鼠通过抓钩在森林中来回摆动，我们使用了 ropeJoint 这个关节组件。这个组件会限制两个刚体间的最大距离，达到绳子的效果。ropeJoint 一端连接仓鼠，另一端连接一个叫 ceiling 的刚体。ceiling 位于游戏画面的最上端，为仓鼠的抓钩提供一个附着点。

游戏中松开抓钩，可以通过将这个 ropeJoint 的 active 设置为 false 来实现。而发射抓钩时，需要首先计算附着点的位置(也就是 ropeJoint 的 connectedAnchor 属性)，然后激活 ropeJoint.

游戏中的碰撞处理，是通过碰撞组件实现的。借助 polygonCollider，我们可以更加精细的控制碰撞范围。在仓鼠的脚本中添加碰撞的回调函数，即可处理仓鼠与其他物品的碰撞事件。

游戏实现的难点集中在以下几个方面。

首先是伸出与收回抓钩时的动画。正如上文所说，发射抓钩时，首先会计算附着点的位置并记录下来。为了显得更加真实，ropeJoint 并不是在发射抓钩的同时激活的。发射抓钩后的每一帧，都会计算当前仓鼠距离附着点的距离，以及所成的角度。同时，抓钩的长度也会逐渐增加。用当前抓钩的长度，以及所成的角度来更新抓钩的位置，就可以实现抓钩逐渐变长的效果。当抓钩的长度超过当前仓鼠到附着点的距离时，激活 ropeJoint，并将 maxLength 属性设为当前二者的距离。

收回抓钩时类似。在松开抓钩时将关闭 ropeJoint。之后每一帧更新角度，并缩短抓钩长度。当抓钩长度小于 0 时就不再显示抓钩了。

由于我们使用一张长方形的图片来绘制抓钩，只需要简单的更改其 width 属性，通过该属性来拉伸/压缩图片，实现抓钩的伸长与缩短。但是这样处理会使得抓钩末端的钩子同样被拉伸/压缩。我们通过将绳子与钩子分离的方式解决了这个问题。将钩子作为绳子的子节点，始终保持钩子位于绳子的最前端。通过这样的方式实现了拉伸/压缩绳子时钩子不变的效果。

其次是无限背景的实现。经过前期的试错，我们最终的方案为，使用两张完全相同的背景图片，交替显示这两个图片。每当左边的图片位于屏幕范围以外时，将其移动到右边图片的右边。同时由于仓鼠无法向左边发射抓钩，所以不需要考虑右边的图片需要移动到左边的情况。

由于游戏中使用了很多异步执行的函数，带来了很多 bug。例如仓鼠吃掉蘑菇以后会进入无敌状态并维持 5 秒，这 5 秒内会持续翻滚。5 秒后该翻滚的动作会被停下(stopAction)。但是如果在这 5 秒内由于触及地图底部而死，并重新开始游戏，那么 5 秒后的 stopAction 就会作用在 null 上。类似于这样的问题花费了我们很多的时间，我们也在异步执行的地方都加入了各种判断来保证程序的鲁棒性。

将小游戏分包后发布到微信平台时同样需要了许多问题。加载分包时，微信 web 开发工具报错 net::ERR_BLOCKED_BY_CLIENT。我们发现这是因为加载分包与加载场景中的图片位于同一个生命周期回调内，导致某些图片在加载完成之前被请求。经过一番探索，并没有在网上找到解决这类问题的方案。最终我们选择在所有场景之前，加入一个 preload 场景，作为初始场景。该场景负责加载分包，并在加载完成之后切换到开始游戏的场景。

## 游戏测试

我们在不同品牌，不同屏幕尺寸的移动设备上进行过测试，对于屏幕的适配较好，同时没有明显的卡顿现象。

游戏的代码逻辑同样经过我们的大量测试，并没有发现异常情况。

## 亮点内容

// 精美的动画设计与视觉特效 别出心裁的物理系统 多样的操作反馈

## 游戏的数值设计

// 松开绳子加速 屋顶反弹 怪物与蘑菇的间距 无敌状态时间 重力加速度

## 游戏的优化

在游戏场景中，仓鼠向前飞跃，前方会不断生成物品，包括星星、蘑菇、云，等等。大部分物品都会很快离开视野范围。如果不及时清理这些物品，那么每一帧的运算量会不断增长，其中包括(1) 更新这些物品坐标，(2) 这些物品的动画效果，(3) 降低全局事件监听的效率，(4) 降低查找结点的效率，最终造成游戏的卡顿。我们通过每过一段时间(100ms)，及时清理屏幕范围外的物品，避免了较长游戏时间后的卡顿问题。

此外，对于在仓鼠前方生成物品，更新分数等操作，它们并不需要每一帧都执行。我们通过 setInterval 或 setTimeOut 的方法降低了每一帧的运算量。

## 分工

张欣炜主要完成了项目构建，并对 cocos 引擎的进行了早期的探索与踩坑，包括物理引擎的使用，事件响应及组件间消息传递的实现方式。实现了游戏主体逻辑，创建游戏中的模型，并为游戏添加了音效。

汪元标提出了多个版本的游戏创意，在其基础上设计了这款游戏。完成了游戏的流程控制，设计了模块框架，实现了场景的逻辑控制。制作了游戏的动画、动作特效，进行了美术设计。

## 参考资料

[1\] [Cocos Creator v2.0 用户手册](https://docs.cocos.com/creator/manual/zh/)

[2\] [Cocos Creator JavaScript engine API reference](https://docs.cocos.com/creator/api/zh/)
